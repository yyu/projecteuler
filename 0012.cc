// http://projecteuler.net/problem=12
//
// The sequence of triangle numbers is generated by adding the natural numbers.
// So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28.
// The first ten terms would be:
//         1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
// Let us list the factors of the first seven triangle numbers:
//         1 : 1
//         3 : 1, 3
//         6 : 1, 2, 3,  6
//        10 : 1, 2, 5, 10
//        15 : 1, 3, 5, 15
//        21 : 1, 3, 7, 21
//        28 : 1, 2, 4,  7, 14, 28
// We can see that 28 is the first triangle number to have over five divisors.
// What is the value of the first triangle number to have over five hundred divisors?
//
// Answer: 76576500 (the 12375th triangle number)

#include <iostream>
#include <vector>
#include <cstdio>
#include <cassert>

std::vector<int> primes;

inline int tri_num(int n) {
    return (n * (n + 1)) >> 1;
}

int next_prime(int p) {
    assert(primes[p] == p);
    int N = primes.size();
    int i;
    for (i = p + 1; i < N; i++)
        if (primes[i])
            break;
    assert(i < N);
    return i;
}

void calc_primes(int N) {
    primes.assign(N, 0);
    for (int i = 0; i < N; i++)
        primes[i] = i;
    for (int p = 2; p * p <= N; p = next_prime(p))
        for (int i = p * 2; i < N; i += p)
            primes[i] = 0;
}

// if
//     N = p₁ⁿ¹·p₂ⁿ²·p₃ⁿ³·...
// then the number of divisors D(N) can be computed from
//     D(N) = (n₁+1)·(n₂+1)·(n₃+1)·...
int count_fac(int n) {
    int cnt = 1;
    for (int p = 2; p <= n; p = next_prime(p)) {
        int k = 0;
        while (n % p == 0) {
            k++;
            n /= p;
        }
        cnt *= k + 1;
    }
    return cnt;
}

void foo(int k) {
    int n = 1;
    for (; ; n++) {
        int t = tri_num(n);
        int c = count_fac(t);
        // printf("%d : %d (%d)\n", n, t, c);
        if (c > k) {
            printf("%d : %d (%d factors)\n", n, t, c);
            return;
        }
    }
}

int main(int argc, char* argv[]) {
    calc_primes(65555);
    foo(500);
    return 0;
}
